# 面向对象

**java面向对象编程的知识点**

## 1、方法

### **语法**

1. 形参列表：
   - 表示成员输入参数 cal(int n),getSum(int num1,int num2)
   - 一个方法可以0个参数，也可以多个参数，可以是任意类型，调用带参数方法时必须对应着参数列表传入相同类型，顺序、个数必须一致！
2. 数据类型：
   - 一个方法最多有一个返回值
   - 返回类型可以为任意类型
   - 如果方法要求有返回数据类型，则方法体重最后的执行语句必须为return值；且返回值类型必须和return的值类型一致或兼容。
   - 如果方法时void，则方法体中可以没有return语句
3. 方法主体：表示为了实现某一功能代码块
4. return 语句不是必须的。

```java
public 返回数据类型 方法名(形参列表..){ //方法体
	语句；
	return 返回值;
}
```

### 方法递归

**规则：**

- 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
- 方法的局部变量是独立的，不会相互影响,比如n变量
- 如果方法中使用的是引用类型变量(比如数组，对象)，就会共享该引用类型的数据   
- 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)    
- 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。  
- 方法名：必须相同
- 形参列表：必须不同(形参类型或个数或顺序，至少有一样无，参数名要求) 
- 返回类型：无要求  

### 可变参数

**java允许将同一类中多个同名同功能但参数个数不同的方法，封装成一个方法。就可以通过可变参数实现**

**语法**

```java
方法修饰符 返回类型 方法名(数据类型... 形参名){
}
public int sum(int... nums){
}
```

**规则：**

- 可变参数的实参可以为0个或者任意多个
- 可变参数的实参可以为数组。
- 可变参数的本质就是数组
- 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
- 一个形参列表中只能出现一个可变形参   

### 方法重载

在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。

```java
public int add(int num1,int num2){
}
public int add(double dou1,double dou2){
}
```



## 2、类与对象

**区别**

- 类是抽象的，概念的，代表一类事物，比如人类，猫类..，即它是数据类型
- 对象是具体的，实际的，代表一个具体事务，即 是实例
- 类是对象的模板，对象是类的一个个体，对应一个实例  

### 内存分配机制

**java内存结构：**

- 栈：一般存放基本数据类型(局部变量)
- 堆：存放对象(Cat car,数组等)
- 方法区：常量池(常量，比如字符串)，类加载信息

```java
对象创建的流程简单分析
    Person p = new Person();
	p.name = "jack";
	p.age = 10;
1、先加载Person类信息(属性和方法信息，只会加载一次)
2、在堆中分配空间，进行默认初始化(看规则)
3、把地址给 p,p就指向对象
4、进行指定初始化，比如p.name = "jack";  p.age = 10;    
```

### 属性/成员变量

- 属性是类的一个组成部分，一般是基本数据类型，也可是引用类型(对象，数组)。
- 语法：访问修饰符 属性类型 属性名； private int number;
- 如果属性不赋值，有默认值，规则和数组一致。 

### 成员方法

跟上方**方法介绍**一样。属于类的一个组成部分

### 类变量和类方法（静态属性和静态方法）

类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何要给该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它是，修改的也是同一个变量

```java
定义类变量
访问修饰符 static 数据类型 变量名;

访问类变量
类名.类变量名【推荐】
或者 对象名.类变量名【静态变量的访问修饰符的访问权限和范围 和 普通属性是一样的。】
```

**类变量和类方法的注意事项：**

- 类变量与实例变量区别：类变量是该类的所有对象共享的，而实例变量是每个对象独享的。
- 实例变量不能通过 类名.类变量名 方式访问。
- 类变量是在类加载时就初始化了，即使没有创建对象，只要类加载了，就可以使用类变量了。
- 类变量的生命周期是随类的加载开始，随着类消亡而销毁。
- 当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。
- 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：类方法中无this参数 普通方法中隐含着this的参数
- 类方法可以通过类名调用，也可以通过对象名调用。
- 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数),不能通过类名调用    
- 类方法中不允许使用和对象有关的关键字。普通方法可以
- 静态方法中只能访问静态变量或静态方法。
- 普通成员方法，既可以访问 普通变量(方法),也可以访问静态变量(方法)。

### Main方法

在main()方法中，我们可以直接调用main方法所在类的静态方法或静态属性。

但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员.  

解释main方法的形式:public static void main(Stringl] args){}
- main方法是虚拟机调用
- java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public
- java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static
- 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数.    

### 作用域

- java作用域分类
      全局变量：也就是属性，作用域为整个类体
      局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中
- 全局变量(属性)可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值
- 属性和局部变量可以重名，访问时遵循就近原则
- 属性生命周期长，伴随着对象的创建和销毁，局部变量，生命周期短，伴随着它的代码块的执行而创建，代码块结束而销毁，即在一次方法调用过程中
- 作用域范围不同：
      全局变量/属性：可以被本类使用，或其他类使用(通过对象调用)   
      局部变量：只能在本类中对应的方法中使用
- 修饰符不同：
      全局变量/属性可以加修饰符
      局部变量不可以加修饰符

### 构造方法/构造器

构造方法又叫构造器(constructor)，是类的一种特殊的方法，主要作用是完成对新对象的初始化，特点：

- 方法名和类名相同
- 没有返回值
- 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化

**语法：**

```java
[修饰符] 方法名(形参列表){
	方法体；
} 
```

**使用：**

- 一个类可以定义多个不同的构造器，即构造器重载    
- 构造器名和类名要相同
- 构造器没有返回值    
- 构造器是完成对象的初始化.并不是创建对象
- 在创建对象时,系统自动的调用该类的构造方法
- 如果程序员没有定义构造方法，系统会自动给类生成一个默认无参构造方法(也叫默认构造方法)，比如Person ()，使用javap指令反编译看看   
- 一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下,即:Person(){} 

### this关键字和super关键字

**this关键字：**

- this关键字可以用来访问本类的属性、方法、构造器
- this用于区分当前类的属性和局部变量
- 访问成员方法的语法:this.方法名(参数列表);
- 访问构造器语法:this(参数列表);注意只能在构造器中使用(即只能在构造器中访问另外一个构造器,必须放在第一条语句)
- this不能在类定义的外部使用，只能在类定义的方法中使用。 

**super关键字：** 

super代表父类的引用，用于访问父类的属性、方法、构造器

- 访问父类的属性，但不能访问父类的private属性，super.属性名
- 访问父类的方法，不能访问父类的private方法，super.方法名(参数列表)
- 访问父类的构造器：super(参数列表);只能放在构造器的第一句，只能出现一句！

**super细节：**

- 调用父类的构造器的好处(分工明确，父类属性由父类初始化，子类的属性由子类初始化)
- 当子类中有和父类中的成员(属性和方法)重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果！
- super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循的就近原则。A->B->C

#### 比较

| 区别点     | this                                                   | super                                      |
| ---------- | ------------------------------------------------------ | ------------------------------------------ |
| 访问属性   | 访问本类中的属性，如果本类没有此属性则从父类中继续查找 | 从父类开始查找属性                         |
| 调用方法   | 访问本类中的方法，如果本类没有此方法则从父类中继续查找 | 从父类开始查找方法                         |
| 调用构造器 | 调用本类构造器，必须放在构造器的首行                   | 调用父类的构造器，必须放在子类构造器的首行 |
| 特殊       | 表示当前对象                                           | 子类中访问父类对象                         |

### finalize方法

- 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作
- 什么时候被回收:当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法。 3．垃圾回收机制的调用，是由系统来决定(即有自己的GC算法),也可以通过System.gc()主动触发垃圾回收机制。

**//在实际开发中，几乎不会运用到finalize.**    

### 包

**作用:**

- 区分相同名字的类
- 当类很多时，可以很好的管理类
- 控制访问范围   

**语法：**

- package com.Lmj
  - package 关键字，表示打包    
  - com.Lmj 表示包名

**命名规则：**

只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字
一般是小写字母+小圆点 
com.公司名.项目名.业务模块名

**常用的包**

```java
java.lang.* //lang包是基本包，默认引入,不需要再引入.
java.util.* //util包，系统提供的工具包,工具类，使用 Scanner    
java.net.* //网络包，网络开发
java.awt.* //是做java的界面开发，GUI
```

### 访问修饰符

java提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围):

- 公开级别:用public修饰.对外公开
- 受保护级别:用protected修饰.对子类和同一个包中的类公开
- 默认级别:没有修饰符号.向同一个包的类公开.    
- 私有级别:用private修饰,只有类本身可以访问,不对外公开.

| 访问级别 | 访问控制修饰符 | 同类 | 同包 | 子类 | 不同包 |
| -------- | -------------- | ---- | ---- | ---- | ------ |
| 公开     | public         | √    | √    | √    | √      |
| 受保护   | protected      | √    | √    | √    | ×      |
| 默认     | 没有修饰符     | √    | √    | ×    | ×      |
| 私有     | private        | √    | ×    | ×    | ×      |



## 3、面向对象三大特征

> 面向对象编程的三大特征：封装、继承和多态。 如果有人问你四大就加一个 抽象

### 封装

封装(encapsulate)就是把抽象的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法],才能对数据进行操作。

**实现**

```java
1）将属性进行私有化private 【不能直接修改属性】
2）提供一个公共的（public）set方法，用于对属性判断并赋值
    public void setXxx（类型 参数名）{//Xxx 表示某个属性
	//加入数据验证的业务逻辑
    属性 = 参数名;
}
3）提供一个公共的（public）get方法，用于获取属性的值
    public 数据类型 getXxx(){//权限判断，Xxx某个属性
    	return xx;
	}    
```

**好处**

```java
1）隐藏实现细节：方法（连接数据库）<--调用（传入参数..）
2）可以对数据进行验证，保证安全合理
    Person{name,age}
	Person p = new Person();
	p.name = "jack";
	p.age = 1200;
```

### 继承

在OOP的术语中，我们把`被继承的类`称为超类（super class），父类（parent class），基类（base class），把`继承别的类的类`称为子类（subclass），扩展类（extended class）。

Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有`Object`特殊，它没有父类。

**语法**

```java
class 子类 extends 父类{
}
1、子类就会自动拥有父类定义的属性和方法
2、父类又叫 超类，基类。
3、子类又叫派生类 
```

**继承的细节及事项：**

- 子类继承了所有的属性和方法，但是私有属性和方法不能在子类直接访问，要通过公共的方法去访问
- 子类必须调用父类的构造器，完成父类的初始化
- 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过
- 如果希望指定去调用父类的某个构造器，则显式的调用一下：super(参数列表)
- super在使用时，必须放在构造器第一行（super只能在构造器中使用）
- super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器
- java所有类都是Object类的子类，Object时所有类的基类。
- 父类构造器的调用不限于直接父类！将一直往上追溯直到Object类（顶级父类）
- 子类最多只能继承一个父类（指直接继承），即Java中时单继承机制
- 不能滥用继承，子类和父类之间必须满足is-a的逻辑关系

#### 方法重写

方法重写就是子类有一个方法，和父类的某个方法的名字、返回类型、参数一样，那么我们就会说子类的这个方法覆盖了父类的方法。

**条件：**

- 子类的方法的参数，方法名称，要和父类方法的参数，方法名称完全一样。
- 子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类，比如 父类 返回类型是 Object，子类方法返回类型是String
- 子类方法不能缩小父类方法的访问权限

### 多态

对象的多态（核心、重难点）

**体现：**

- 一个对象的编译类型和运行类型可以不一致
- 编译类型在定义对象时，就确定了，不能改变
- 运行类型时可以变化的
- 编译类型看定义时=号的左边，运行类型看=号的 右边

#### 多态的向上转型

前提：两个对象(类)存在继承关系

- **本质**：父类的引用指向了子类的对象

- **语法**：父类类型 引用名 = new 子类类型();

- **特点**：编译类型看左边，运行类型看右边。
    可以调用父类中的所有成员（遵守访问权限），
    不能调用子类中的特有成员；
    最终运行效果看子类的具体实现！

#### 多态的向下转型

- 语法： 子类类型 引用名 = (子类类型) 父类引用;
- 只能强转父类的引用，不能强转父类的对象
- 要求父类的引用必须指向的是当前目标类型的对象
- 可以调用子类类型中所有的成员

#### 动态绑定机制

- 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定
- 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

```java
class AA{
    public void run(){ System.out.println("AA run"); }
    public void eat(){ System.out.println("AA eat"); }
}
class BB extends AA{
    public void run(){ System.out.println("BB run"); }
    public void study(){ System.out.println("BB study"); }
}
main方法{
    	//父类的引用指向子类对象
        AA aa = new BB();//向上转型
        aa.eat(); //AA eat
        aa.run(); //BB run
		//把指向子类对象的父类引用，转成指向子类对象的子类引用
        BB bb = (BB)aa;//向下转型
        bb.run();//BB run
        bb.eat();//AA eat
        bb.study();//BB study
}
```



## 4、面向对象进阶

### 代码块

代码化块又称为初始化块，属于类中的成员[即 是类的一部分],类似于方法，将逻辑语句封装在方法体中，通过{}包围起来

但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。

语法：
[修饰符]{
    代码
};
代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块/非静态代码块。

**好处：**

相当于另外一种形式的构造器(对构造器的补充机制)，可以做初始化的操作

**使用注意事项：**

- 静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。普通代码块则每创建一个对象，就执行。
- 类什么时候被加载：①创建对象实例时(new)②创建子类对象实例，父类也会被加载③使用类的态成员时(静态属性、静态方法)    
- 普通代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行。
  小结：1、static代码块是类加载时，执行，只会执行一次。
      2、普通代码块时在创建对象时调用的，创建一次，调用一次
      3、类加载的3种情况
- 创建一个对象时，在一个类中调用顺序是：
      ①调用静态代码块和静态属性初始化(注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用)
      ②调用普通代码块和普通属性的初始化(注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用)
- 创建一个子类对象时，他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序：
      ①父类的静态代码块和静态属性(优先级一样，按定义顺序执行)
      ②子类的静态代码块和静态属性(优先级一样，按定义顺序执行)
      ③父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
      ④父类的构造方法
      ⑤子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
      ⑥子类的构造方法
- 静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任意成员。

### final关键字

**final可以修饰类、属性、方法和局部变量**

- 当不希望类被继承时，可以用final修饰。
- 当不希望父类的某个方法被子类覆盖/重写(override)时，可以用final关键字修饰。
- 当不希望类的某个属性的值被修改，可以用final修饰
- 当不希望某个局部变量被修改，可以使用final修饰
- 一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法。
- final方法不能修饰构造方法(构造器)
- final和static往往搭配使用，效率更高，底层编译器做了优化处理。
- 包装类(Integer,Double,Float,Boolean等都是final)，String也是final类

**final使用注意事项**

- final修饰的属性又叫常量
- final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一：①定义时：如public final double TAX_PATE=0.08; ②在构造器中 ③在代码块中
- 如果final修饰的属性是静态的，则初始化的位置只能是①定义时 ②在静态代码块 不能在构造器中赋值。
- final类不能继承，但是可以实例化对象
- 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承  

### 抽象类

- 用abstract关键字来修饰一个类时，这个类就叫抽象类

  访问修饰符 abstract 类名{
  	}

- 用abstract关键字来修饰一个方法时，这个方法就是抽象方法
      访问修饰符abstract返回类型 方法名(参数列表);//没有方法体

- 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()

- 抽象类，是考官比较爱问的知识点，再框架和设计模式使用较多

**抽象类的使用事项：**

- 抽象类不能被实例化
- 抽象类不一定要包含abstract方法。抽象类可以没有abstract方法
- 一旦类包含了abstract方法，则这个类必须声明为abstract
- abstract只能修饰类和方法，不能修饰属性和其他的
- 抽象类可以有任意成员【因为抽象类还是类】
- 抽象类方法不能用主体，即不能实现
- 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。
- 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的

### 接口

接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。

- 在jdk.7.0前接口里的所有方法都没有方法体，即都是抽象方法。
- jdk8.0后接口可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现

**语法**

```java
    interface 接口名{
    	//属性
    	//方法(1.抽象方法 2.默认实现方法 3.静态方法)
	}
	class 类名 implements 接口{
        自己属性;
        自己方法;
        必须实现的接口的抽象方法
    }
```

**接口使用事项**

- 接口不能被实例化
- 接口中所有的方法是 public方法，接口中抽象方法，可以不用abstract修饰：void aaa()实际上是 abstract void aa();
- 一个普通类实现接口，就必须将该接口的所有方法都实现。
- 抽象类实现接口，可以不用实现接口的方法
- 一个类同时可以实现多个接口
- 接口中的属性，只能是final的，而且是public static final 修饰符。比如：int a=1;实际上是 public static final a=1;(必须初始化)
- 接口中属性的访问形式:接口名.属性名
- 一个接口不能继承其他的类，但是可以继承多个别的接口：interface A extends B,C{}
- 接口的修饰符 只能是public和默认，这点和类的修饰符是一样的

#### 实现接口VS继承类

**接口和继承解决的问题不同：**
	继承的价值主要在于：解决代码的复用性和可维护性。
    接口的价值主要在于：设计，设计好各种规范(方法),让其他类去实现这些方法。即更加灵活..

  **接口比继承更加灵活：**
    接口比继承更加灵活，继承是满足is-a的关系，而接口只需满足like-a的关系。

**接口在一定程度上实现代码解耦[即：接口规范性+动态绑定机制]**    

#### 接口的多态传递

```java
public class InterfacePolyPass {
    public static void main(String[] args) {
        //接口类型的变量可以指向，实现了该接口的类的对象实例
        IG ig = new Teacher();
        //如果IG 继承了IH接口，而Teacher类实现了 IG接口
        //那么，实际上就相当于 Teacher 类也实现了 IH接口
        //这就是所谓的 接口多态多态传递现象
        IH ih = new Teacher();
    }
}
interface IH{
    void h1();
}
interface IG extends IH{
}
class Teacher implements IG{
    @Override
    public void h1() {
    }
}
```

### 内部类

一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部类(outer class)。

是我们类的第五大成员(成员：[属性、方法、构造器、代码块、内部类])，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。

**语法：**

```java
	class Outer{//外部类
        class Inner{//内部类
        }
    }
	class Other{//外部其他类
    }
```

**分类：**

- 定义在外部类局部位置上(比如方法内)：
  - 局部内部类(有类名)
  - 匿名内部类(没有类名)
- 定义在外部类的成员位置上：
  - 成员内部类(没用static修饰)
  - 静态内部类(使用static修饰)

重点还是掌握 匿名内部类使用
	new 类/接口(参数列表){
    	//...
	};
成员内部类，静态内部类 是放在外部类成员位置，本质就是一个成员

#### 局部内部类

局部内部类是定义在外部类的局部位置，比如方法中，并且有类名。

- 可以直接访问外部类的所有成员，包含私有化
- 不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final
- 作用域：仅仅在定义它的方法或代码块中。
- 局部内部类---访问--->外部类的成员[访问方式：直接访问]
- 外部类---访问--->局部内部类的成员[访问方式：创建对象，在访问(注意：必须在作用域内)    
- 外部其他类---不能访问--->局部内部类(因为 局部内部类地位是一个局部变量)
- 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类成员，则可以使用(外部类名.this.成员) 去访问

**code**

```java
public class LocalInnerClass {
    public static void main(String[] args) {
        Outer02 outer02 = new Outer02();
        outer02.m1();
        System.out.println("Outer02的hashcode=" + outer02);
    }
}

class Outer02{//外部类
    private int n1 = 100;
    private void m2(){
        System.out.println("Outer m2()");
    }//私有方法
    public void m1(){//方法
        //1.局部内部类是定义在外部类的局部位置，通常在方法
        //3.不能添加访问修饰符，但是可以使用final修饰
        //4.作用域：仅仅在定义它的方法或代码块中
        final class Inner02{//局部内部类(本质仍然是一个类)
            //2.可以直接访问外部类的所有成员，包含私有的
            private int n1 = 800;
            public void f1(){
                //5.局部内部类可以直接访问外部类的成员，比如下面 外部类n1 和 m2()
                //7.如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类成员，使用(外部类名.this.成员)去访问
                System.out.println("n1=" + n1 + " 外部类的n1=" + Outer02.this.n1);
                System.out.println("Outer02.this hashcode=" + Outer02.this);
                m2();
            }
        }
        //6.外部类在方法中，可以创建Inner02对象，然后调用方法即可
        Inner02 inner02 = new Inner02();
        inner02.f1();
    }
}    
```

#### 匿名内部类

匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名

特点：本质是类、内部类、该类没有名字、同时还是一个对象

- 匿名内部类的基本语法：
      	new 类或接口(参数列表){
      		类体
    		};
- 匿名内部类是一个类的定义，同时它本身也是一个对象，从语法上看，它既有定义类的特征，也有创建对象的特征，因此可以调用匿名内部类方法。
- 可以直接访问外部类的所有成员，包含私有的
- 不能添加访问修饰符，因为它的地位就是一个局部变量
- 作用域：仅仅在定义它的方法或代码块中
- 匿名内部类---访问--->外部类成员[访问方式：直接访问]

**code:**

```java
public class AnonymousInnerClass {
    public static void main(String[] args) {
        Outer04 outer04 = new Outer04();
        outer04.method();
    }
}

class Outer04 {//外部类
    private int n1 = 10;//属性
    public void method() {//方法
        //基于接口的匿名内部类
        //1.需求：要使用IA接口，并创建对象
        //2.传统方式，是写一个类，实现该接口，并创建对象
        //3.需求：Tiger/Gog类只是使用一次，后面再不使用
        //4.可以使用匿名内部类来简化开发
        //5.tiger的编译类型 IA
        //6.tiger的运行类型 就是匿名内部类 Outer04$1
        /*
            我们看底层 会分配 类名 Outer04$1
            class Outer04$1 implements IA{
                @Override
                public void cry(){
                    System.out.println("老虎叫唤...");
                }
            }
        */
        //7.jdk底层在创建匿名内部类 Outer04$1，立即就创建了 Outer04$1实例，并且把地址返回给tiger
        //8.匿名内部类使用一次，就不能再使用
        IA tiger = new IA(){
            @Override
            public void cry() {
                System.out.println("老虎叫唤...");
            }
        };
        System.out.println("tiger的运行类型="+tiger.getClass());
        tiger.cry();
        tiger.cry();
        tiger.cry();

        //演示基于类的匿名内部类
        //1.father编译类型 Father
        //2.father运行类型 Outer04$1
        //3.底层会创建匿名内部类
        /*
            class Outer04$2 extends Father{
            }
         */
        //4.同时也直接返回了 匿名内部类 Outer04$2的对象
        //5.注意("jack")参数列表会传递给 构造器
        Father father = new Father("javk"){
            @Override
            public void test() {
                System.out.println("匿名内部类重写了test方法");
            }
        };
        System.out.println("father对象的运行类型="+father.getClass());//Outer04$2
        father.test();

        //基于抽象类的匿名内部类
        Animal animal = new Animal(){
            @Override
            void eat() {
                System.out.println("小狗吃骨头。。。。");
            }
        };
        animal.eat();
    }
}

interface IA {//接口
    public void cry();
}
//class Tiger implements IA {
//    @Override
//    public void cry() {
//        System.out.println("老虎叫唤...");
//    }
//}
//class Dog implements IA {
//    @Override
//    public void cry() {
//        System.out.println("小狗汪汪...");
//    }
//}

class Father{//类
    public Father(String name){//构造器
        System.out.println("接受到的name="+name);
    }
    public void test(){//方法
    }
}
abstract class Animal{//抽象类
    abstract void eat();
}
```

#### 成员内部类

成员内部类是定义在外部类的成员位置，并且没有static修饰。

- 可以直接访问外部类所有成员，包含私有的
- 可以添加任意访问修饰符(public、protected、默认、private),因为它的地位就是一个成员。
- 作用域和外部类的其他成员一样，为整个类体，在外部类的成员方法中创建成员内部类对象，再调用方法。
- 成员内部类---访问--->外部类成员(比如：属性)[访问方式：直接访问]
- 外部类---访问--->成员内部类[访问方式：创建对象，再访问]
- 外部其他类---访问--->成员内部类
- 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问

**code:**

```java
public class Test10 {
    public static void main(String[] args) {
        //外部类访问内部类。方式一
        Outer01 outer01 = new Outer01();
        Outer01.Inter01 inter01 = outer01.new Inter01();
        //方式二
        Outer01.Inter01 inter011 = new Outer01().new Inter01();
        //方式三，使用一个方法来获取
        Outer01.Inter01 inter012 = new Outer01().getInter01();
    }
}
class Outer01{
    private int n1=10;
    public String name="张三";
    class Inter01{
        public void say(){
            System.out.println("Outer的n1="+n1+"outer01 的name="+name);
        }
    }
    public Inter01 getInter01(){
        return new Inter01();
    }
    private void show(){
        Inter01 inter01 = new Inter01();
        inter01.say();
    }
}  
```

#### 静态内部类

静态内部类是定义再外部类的成员位置，并且有static修饰

- 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员
- 可以添加任意访问修饰符(public、protected、默认、private)，因为它的地位就是一个成员
- 作用域：同其他的成员，为整个类体
- 静态内部类---访问--->外部类(比如：静态属性)[访问方式：直接访问所有静态成员]
- 外部类---访问--->静态内部类 访问方式：创建对象，再访问
- 如果外部类和静态内部类的成员重名时，静态内部类访问时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.成员)去访问

**code:**

```java
public class StaticlnnerClass01 {
    public static void main(String[] args) {
        Outer10 outer10 = new Outer10();
        outer10.m1();
        //外部其他类 使用静态内部类
        //方式一
        //因为静态内部类，是可以通过类名直接访问(前提是满足访问权限)
        Outer10.Inner10 inner10 = new Outer10.Inner10();
        inner10.say();
        //方式2
        //编写一个方法，可以返回一个静态内部类
        Outer10.Inner10 inner101 = outer10.getInter10();
        inner101.say();

        Outer10.Inner10 inner10_ = Outer10.getInter10_();
        inner10_.say();
    }
}
class Outer10{//外部类
    private int n1 = 10;
    private static String name = "张三";
    private static void cry(){}
    //Inner10就是静态内部类
    //1.放在外部类的成员位置
    //2.使用static 修饰
    //3.可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员
    //4.可以添加任意访问修饰符(public、protected、默认、private)，因为它的地位就是一个成员
    static class Inner10{
        private static String name = "里斯";
        public void say(){//就近原则
            System.out.println(name+" 外部类name= " + Outer10.name);
            cry();
        }
    }
    public void m1(){
        Inner10 inner10 = new Inner10();
        inner10.say();
    }
    public Inner10 getInter10(){
        return new Inner10();
    }
    public static Inner10 getInter10_(){
        return new Inner10();
    }
}
```

