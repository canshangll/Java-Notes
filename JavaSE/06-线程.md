# 线程

**创建线程的方式：**

- 继承Thread类，重写run方法
- 实现Runnable接口，重写run方法

**继承Thread VS 实现Runnable的区别：**

- 本质上没有区别，Thread类本身就实现了Runnable接口
- 实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制，建议使用Runnable。

**线程终止：**

- 当线程完成任务后，会自动退出。
- 还可以通过使用变量来控制run方法退出的方式停止线程，即通知方式

**线程常用方法：**

- setName：设置线程名称，使之与参数name相同
- getName：返回该线程的名称
- start：使该线程开始执行；Java虚拟机底层调用该线程的start0方法
- run：调用线程对象run方法
- setPriority：更改线程的优先级
- getPriority：获取线程的优先级
- sleep：在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)
- interrupt：中断线程,但并没有真正的结束线程，所以一般用于中断正在休眠线程
- yield:线程的礼让，让出cpu,让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功。
- join：线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所以的任务

**用户线程和守护线程：**

JDK中用Thread.State枚举表示了线程的几种状态
public static enum Thread.State extends Enum<Thread.State>

**线程状态：可以处以以下状态之一：**

- NEW:尚未启动的线程处于此状态。
- RUNNABLE：在Java虚拟机中执行的线程处于此状态。
- BLOCKED：被阻塞等待监视器锁定的线程处于此状态。
- WAITING：正在等待另一个线程执行特定动作的线程处于此状态。
- TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。
- TERMINATED：已推出的线程处于此状态。

**Synchronized**

*线程同步机制*

- 在多线程编程，一些敏感数据不允许被多个线程同时访问，此时使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，一保证数据的完整性。
- 线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。

*同步具体方法-Synchronized*

- 同步代码块
          synchronized(对象){ //得到对象的锁，才能操作同步代码
          	//需要被同步代码;
      	}
- synchronized还可以放在方法声明中，表示整个方法-为同步方法
  		public synchronized void m(String name){
              //需要被同步的代码
          }     

**互斥锁：**

- 每个对象都对应一个可称为"互斥锁"的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
- 关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问
- 同步的局限性：导致程序的执行效率要降低
- 同步方法(非静态的)的锁可以是this，也可以是其他对象(要求是同一个对象)
- 同步方法(静态的)的锁为当前类本身。

**线程的死锁：**

多个线程都占用了对方的资源锁，但不肯相让，导致了死锁，在编程是一定要避免死锁的发生。